\chapter{Extensions}


\section{Okapi BM25}

\subsection{Okapi BM25} (Basic Approach)
The Okapi BM25 algorithm is a more sophisticated type of TFIDF ranking algorithm.
It's a summation over all words that make up the search term, making use of the TF calculation as well as the IDF calculation along with variables that can be used for optimisation.
The version of the formula used in this project is:

\begin{align}
    OBM25 = \sum_{i=1}^n IDF(w_i) \cdot \frac{TF(w_i)\cdot (k_1 + 1)}{TF(w_i) + k_1\cdot(1 - b + b\cdot \frac{W}{\bar{W}})}
\label{eq:OBM25}
\end{align}

with the optimisation variables set as $k_1 = 1.2$ and $b = 0.75$ since no advanced optimisation was considered and

\begin{itemize}
    \item $OMB25$ is the Okapi BM 25 score
    \item A search term $w$ consists of individual words $w_1, w_2, ..., w_n$
    \item $IDF(w_i)$ is the inverse document frequency score applied to the word $w_i$
    \item $TF(w_i)$ is the term frequency score applied to the word $w_i$
    \item $W$ is the number of words on the webpage
    \item $\bar{W}$ is the average number of words on a webpage
\end{itemize}

\subsection{OkapiBM25Score class} (Technical Description)
As the Okapi BM25 algorithm makes use of both the TF calculation and the TFIDF calculation, these objects were stored as fields in the {\tt OkapiBM25Score} class in a similar manner to what was done for the {\tt TFIDFScore} class.
The optimisation constants and the average document length were set as static fields.
Two helper methods were added: {\tt setAverageDocLength} and {\tt okapiScore}. {\tt setAverageDocLength} calculates the mean number of words per website based on the websites in the index, and {\tt okapiScore} is a recursive method to perform the summation of all the individual scores of all the words in the search query to return to the {\tt getScore} method.

\begin{lstlisting}[language=Java]
    private double okapiScore(int count, String[] words, Website site, InvertedIndex index) {
    int docLength = site.getWords().size();
    if(count != 0) {
        double IDF = this.tfidfScore.IDF(words[count], index);
        double termFrequency = this.tfScore.getScore(words[count], site, index);
        double score = IDF*((termFrequency*(K_1 + 1))/(termFrequency + K_1*(1 - B + B*(docLength/AVERAGE_DOC_LENGTH))));
        return score + okapiScore(count-1, words, site, index);
    } else {
        double IDF = this.tfidfScore.IDF(words[0], index);
        double termFrequency = this.tfScore.getScore(words[0], site, index);
        return IDF*((termFrequency*(K_1 + 1))/(termFrequency + K_1*(1 - B + B*(docLength/AVERAGE_DOC_LENGTH))));
        }
    }
\end{lstlisting}

\subsection{OkapiBM25Score class} (Testing Considerations)
The mathematical correctness of the OBM25 score calculations were verified using unit tests, which can be found in the ScoreTest.java file alongside the unit tests for the other {\tt Score} classes.
The set up was the same as previously mentioned in the Ranking Algorithm's chapter.
Positive tests for single word and multi word query tests were constructed in the following manner:

\begin{itemize}
    \item the word doesn't occur on the specified website
    \item the word doesn't occur in the website index at all
    \item the word occurs once on the specified website
    \item the word occurs once on the specified website and at least one other website
    \item the word occurs more than once on the specified website
    \item multi-word query: words don't occur on the specified website
    \item multi-word query: words occur once on the specified website
    \item multi-word query: words occur more than once on the specified website
    \item multi-word query: words occur once on the specified website and at least one other website
    \item comparison of the above score values
\end{itemize}

Negative testing consideration were harder to formulate.
The most obvious to test would be dividing by 0, however as seen in equation \ref{eq:OBM25}, it's not actually possible for the denominator to be 0 due to the optimisation variables: either $TF(w_i)$ or $\frac{W}{\bar{W}}$ has to be negative, which is not possible.
To that end, no negative tests were considered for the {\tt OkapiBM25} class.

\section{Improve the Client GUI} % Change the client code such that the result of searches are displayed in a nicer way.

We were given the possibility to improve the front-end of the search challenge as an added task. The client side of our product consists of a set of files that dictate, among other things, the aspect of the page, implements the pieces and bits of code that will ultimately allows the user communicate with the server and perform the searches; and arranges the results of the queries in a more user-friendly fashion.\newline
The files containing the code that concerns the front-end of the search engine can be found in the folder static. Here follows each of the files' description:
\begin{itemize}
    \item index.html — This is the first file the browser reads upon accessing the root of a website hosted in any given domain. Hence it holds what other files to read also (such as the styling sheet), provides written unformatted text which will be displayed on the browser, which may also includes links to other webpages.
    \item style.css — It is possible to style a given webpage from a given html file, but it is best practice to do in on a separate file (such as the present one). Should one build a website with several pages (which for each a separate html file is necessary), styling can become cumbersome and even result in styling inconsistencies. So this file provides a styling guide that can be used for several different pages providing consistency among all of them, and for this is only necessary to add the line of code that points to such file in the html.
    \item code.js — It holds the javascript code that allows for changes in the html (or even style), which will result in changes on what the user sees. Our javascript code was responsible for receiving the search term(s), sending them to the server, receiving the results of the given search, and translating them into html.
    \item Image files in static/img/ — Some images needed to provide the website with the desired aspect.
\end{itemize}
The basic implementation of the client GUI allowed the very basic functionality of performing a search. So the accomplished tasks in this regard will be described in the following subsections.

\subsection{Adding content to be displayed by the html}
A wireframe of a preliminary graphic design of the website can be found in the appendix. Several aspects of the GUI were changed to improve the user's experience. We included a footer with links to ITU's website, the course page, as well as our LinkedIn profiles. Overall names of the classes and id's to be used in the styling sheet were also changed to achieve the intended design. Code was also added to include background images.
Additionally, it seemed intuitive to allow the enter key to trigger a search, so such feature was implemented by including a small script in the html file.

\subsection{Styling}
All the aspect of the website was described in the style.css file. In here, virtually everything was changed, namely:
\begin{itemize}
    \item Centering the content of the webpace;
    \item The aspect of every given class, id, link, as well as behaviour of certain elements when, for example, the user hovers the mouse over that specific element;
    \item Providing responsiveness no the website (adjusting the aspect of the content depending on the size of the viewport;
    \item Behaviour of the background images, where they would display as crossfaded slide show;
    \item Behaviour of the searchbar, where it would change its size by clicking on it.
\end{itemize}

\subsection{Adding functionality through javascript}
Changes in the javascript code, which can be found in the static/code.js, where made in order to allow for:
\begin{itemize}
    \item Provide a different answer depending on the given different queries. The cases we accounted for were the following:
    \begin{itemize}
        \item No query was provided;
        \item The query did not provide any result;
        \item The query provided a certain number of results;
    \end{itemize}
    \item Besides the title and the URL, the results are also accompanied by a certain number word from the given website.
    \item Clicking on a result will open it on a new tab (instead of the current tab).
\end{itemize}


\subsection{Subsection 5.2.1}
Text\\
