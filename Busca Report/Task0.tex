\chapter{FileHelper}

\section{Task}
However, before this it should be ensured that the database will be read correctly and any websites not containing either title or words are omitted.

\section{Basic Description}
The {\tt parseFile(String fileName)} method was designed take in consideration data on websites that fulfilled the following format:\\
{\tt *PAGE:http://www.websiteURL.com/}\\
{\tt Website's title}\\
{\tt word 1}\\
{\tt word 2}\\
{\tt ...}\\
{\tt word n}\\
This meant that, for a website to be passed on to the index, it must have a title, an URL, and the amount of words has to be more than zero.

\section{Technical Description}
As part of the set up of this task, the {\tt FileHelper} class - specifically the \\ {\tt parseFile(String filename)} method â€“ was updated such that from the database file, only websites that have a url, title, and at least one word of webpage content are read-in and stored in the server.
This was accomplished by an {\tt if} statements to check the assignments of the url and title fields prior to adding a {\tt new Website} object to the {\tt ArrayList<Website>}. However, the meat of the changes made to this method were to how the method recognised the content of each line scanned in in order to know how to treat it.
Previously, this was accomplished by making use of the knowledge of the very specific file format, {\tt String} methods, and {\tt boolean} field variables.
This was all replaced by two regular expressions:
{\tt Pattern website = Pattern.compile("(https?://[A-Za-z0-9./\_]+)");} \\
{\tt Pattern webTitle = Pattern.compile("[A-Z][a-z]+[A-Za-z0-9\textbackslash s]+?");} \\

and the methods of the {\tt Matcher} class. Though it does not look to be that big of a change, doing so means that the two field variables are no longer needed, hence less has to be juggled when reading and making further changes to the code.

\section{Testing}
White-box tests were developed around the branching statements in the updated method, and a coverage table was produced, please refer to Appendix \ref{tab:Coverage}. From this coverage table the \ref{tab:Expectancy} was produced. The data set data/test-file1.txt is an empty file, and the rest contained the data shown in \ref{tab:DataFiles}. This process using the Coverage and Expectancy table shown in Appendix \ref{app:table}, is an example of how we construct our tests.

JUnit tests were then produced from table \ref{tab:Expectancy}, as found in FileHelperTest.java. Correctness was verfied along two axes: the size of the {\tt List<Website>} returned, and the specific contents of the {\tt List}. As you can see from the Actual Output column of \ref{tab:Expectancy}, the updated code failed test B3, highlighting a weakness in the code, and subsequently had to be debugged. Including another {\tt if} statement after the {\tt while} loop resolved the issue, and following that all tests were passed.