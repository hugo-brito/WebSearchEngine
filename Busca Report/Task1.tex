\chapter{Faster Queries using an Inverted Index}


\section{Task}
When using an search engine the most important aspect is to be able to perform a search and get the results almost instantaneously. One way of doing this is using an Inverted Index, which sorts the websites according to the words contained in each website. Hence when searching for a specific term, instead of going over every website, it will go over all the words instead and then provide the websites related to searched term. While building the Inverted Index can be system heavy, it is a one time operation that will allow the search engine to operate significantly faster. However, before this it should be ensured that the database will be read correctly and any websites not containing either title or words are omitted.

\section{Basic Approach}
Based on the task the {\tt parseFile(String fileName)} have to be able to only take in websites that fulfill the following format:

{\tt *PAGE:http://www.websiteURL.com/} \\
{\tt Website's title} \\
{\tt word} \\
{\tt ...}

The amount of words has to be more than 0, for it to be considered. So it can be given to the index.

The {\tt Index} was generalized into an interface as to make it easy to test the various indices and switch between them. The following methods define the {\tt Index}:
\begin{itemize}
    \item {\tt build} The build method processes a list of websites into the index data structure.
    \item {\tt lookup} Given a query string, returns a list of all websites that contain the query.
    \item {\tt provideIndex} Provides all websites in a given Index as a collection. This specific method was added for the ranking algorithm and test of the index.
\end{itemize}

The {\tt InvertedIndices} where then implemented using inheritance, since both the {\tt InvertedIndexHashMap} and {\tt InvertedIndexTreeMap} can be given exactly the same methods, the only things that differs is the data structure.

\newpage

\section{Technical Description}
In accordance with the task description, a generalised {\tt Index} interface was created. Each of the classes below implements this interface, visualized in \ref{fig:Index:uml}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{figures/Diagram_InvertedIndices}
    \caption{UML Diagram for the Software Architecture of Index data structures.}
    \label{fig:Index:uml}
\end{figure}

\subsection{FileHelper}
As part of the set up of this task, the {\tt FileHelper} specifically the \\ {\tt parseFile(String filename)} method â€“ was updated such that from the database file, only websites that have a url, title, and at least one word of webpage content are read-in and stored in the server.
This was accomplished by an {\tt if} statements to check the assignments of the url and title fields prior to adding a {\tt new Website} object to the {\tt ArrayList<Website>}. However, the meat of the changes made to this method were to how the method recognised the content of each line scanned in in order to know how to treat it.
Previously, this was accomplished by making use of the knowledge of the very specific file format, {\tt String} methods, and {\tt boolean} field variables.
This was all replaced by two regular expressions:

{\tt Pattern website = Pattern.compile("(https?://[A-Za-z0-9./\_]+)");} \\
{\tt Pattern webTitle = Pattern.compile("[A-Z][a-z]+[A-Za-z0-9\textbackslash s]+?");} \\

and the methods of the {\tt Matcher}. Though it does not look to be that big of a change, doing so means that the two field variables are no longer needed, hence less has to be juggled when reading and making further changes to the code.

\subsection{SimpleIndex}
The provided default way of storing indexes was called SimpleIndex. This solution is implemented using an ArrayList<website>, which contains all of the sites and each site than have their own ArrayList<String>  containing all the words on the sites. \\

\subsection{InvertedIndexTreeMap}
The second approach to store indexes was called InvertedIndexTreeMap. Here the relationship between site and it's words is inverted, meaning that each word knows to which sites it belongs to. The underlying data structure of the TreeMap is a Red-Black tree based NavigableMap implementation, sorted either by the natural ordering of it's keys or by a Comparator. TreeMap provides \textit{guaranteed log(n) time} performance for the operations \textbf{containsKey, get, put, remove}.\cite{oracle:treemap} TreeMap use only the amount of memory needed to hold it's items, therefore this solution is suited when it is not known how many items have to be sorted in memory and there are memory limitations. Solutions is also suited when the order in which items have been stored is important and O(log n) search time is acceptable. \cite{baeldung:HashTreeCompared}

\subsection{InvertedIndexHashMap}
The third approach to store indexes was called InvertedIndexHashMap. Also in the HashMap the relationship between the site and it's words is inverted. To accomplish this a HashMap was used, where the words were used as Keys and  a List of websites as a Value.
The underlying data structure of the HashMap is a Hash table based implementation. This implementation gives \textit{constant-time} performance for the basic operations such as \textbf{get} and \textbf{put}. \cite{oracle:hashmap} However this is true under assumption that there are not too many collisions. This is because this Map implementation acts as a basket hash table and when buckets get too large, they get transformed into node of  TreeNodes, similar to those in TreeMap. \cite{baeldung:HashTreeCompared} Some of the downsides of building the HashMap are that it requires more memory than it is necessary to hold it's data and when a HashMap becomes full, it gets resized and rehashed, which is costly. HashMap solutions should be chosen in cases when the approximate amount of items have to be maintained in the collection is known and the order in which items have been stored is not important. \cite{baeldung:HashTreeCompared}


\section{Benchmarking}

In order to choose one of the implementations, namely ArrayList, TreeMap or HashMap, for the Search Engine, the benchmark test was performed to gain empirical data of the performance of each of the implementations. For the benchmark test JMH, a Java harness for building, running, and analysing nano/micro/milli/macro benchmarks, was used. {OpenJDK:jmh} The benchmark  test was carried out using 20 words (random nouns, verbs, adjectives and conjunctions), which were looked-up using the three different indexes implementations and in three differnt size databases: enwiki-tiny, enwiki-small, enwiki-medium. JMH provides information about an average Score, measured in nanoseconds per operation, see results in  table \ref{table:result}\\
During the benchmark it was assured that the test environment is as similar as possible among the different trials, meaning that all tests were performed on the same machine and no other applications running on the background.

\begin{table}[!htbp]
    \caption{\textbf{Benchmark Score in ns/op average for all indices}}
    \begin{tabular}{|c|c|c|c|}
        \hline
        \textbf{Data sets} & \textbf{SimpleIndext} & \textbf{Inv.IndexHashMap} & \textbf{Inv.IndexTreemap} \\ \hline
        \textbf{} & \textbf{avgt Score ns/op} & \textbf{avgt Score ns/op} & \textbf{avgt Score ns/op} \\ \hline
        enwiki-tiny &18944.884&1052.067&1591.311 \\ \hline
        enwiki-small &8819338.592&1883.776&3622.582\\ \hline
        enwiki-medium &233498546.571&27451.020&30176.993 \\ \hline
    \end{tabular}
    \label{table:result}
\end{table}


The benchmark results shows that the SimpleIndex is significantly slower than both of the Inverted Map implementations, 233498546.571 ns/op versus 27451.020 ns/op for the InvertedIndexHashMap and 30176.993 ns/op for the InvertedIndexTreeMap using the enwiki-medium dataset, respectively.
In order to describe the resulsts let the number of websites be m and words be n.
The difference in performance can be explained as fallows: \\
When the SimpeIndex is looking up the search word, it looks though all the sites, which takes \textit{O(m)} time, and for each site it looks through all the words which takes \textit{O(n)} time, therefore total search time is \textit{O($m\cdot n$)}. Two other methods provides faster performance time. InvertedIndexTreeMap provides a  \textit{guaranteed} performance of \textit{O(log(n))}. InvertedIndexTreeMap provides best-case performance of constant time \textit{O(1)} and the worst-case performance since the Java8 of \textit{O(log(n))} time. Worst-case performance occurs, when hash function is not implemented correctly, values are distributed poorly in buckets and there is high hash collision.

%$2 \cdot log(n) + occ$\
There are several considerations when choosing the implementation for storing the data for the Search Engine.

HashMap seams to be better fit than a TreeMap for Search Engine solution, because in this case the order of data is not important versus the performance looking up the websites corresponding the search word is. The HashMap can be expected to perform in constant time which is better than TreeMap's \textit{log(n)} time, and only HashMap's worst-performance is be \textit{log(n)} time. The given data sets are fixed, therefore the costly resizing and rehashing is not going to occur implementing Hashmap. HashMap performed the best on all of the given different size datasets in benchmark test. This is the reasoning for choosing HashMap implementation over the TreeMap implementation for this Search Engine project.




\section{Testing Considerations}
After the above changes were implemented, development tests were written in order determine the viability of the code and whether the changes satisfied the requirements of the task. To that end, JUnit tests were devised for each class that was updated.

\subsubsection{FileHelper tests}

White-box tests were developed around the branching statements in the updated method, and a coverage table was produced.

\begin{table}[!h]
    \caption{Coverage table of the parseFile(String filename) method}
    \begin{tabular}{|l|p{100pt}|l|}
        \hline
        \textbf{Choice} & \textbf{Input property} & \textbf{Input data set} \\ \hline
        1 catch & incorrect file name & A \\ \hline
        1 try & file name & B \\ \hline
        2 while: zero times & empty file & B1 \\ \hline
        2 while: once & file has one line & B2 \\ \hline
        2 while: more than once & file has two lines & B3 \\ \hline
        2 while: more than once & file has at least three lines & B4 \\ \hline
        3 true & the line contains a web url & B3, B4 \\ \hline
        3 false & the line does not contain a web url & B1, B2 \\ \hline
        4 true & either the listOfWords field or the title field is null & B3, B4 \\ \hline
        4 false & both the listOfWords and the title fields are not null & B4 \\ \hline
        5 true & the url field is not null & B4 \\ \hline
        5 false & the url field is null & B3, B4 \\ \hline
        6 true & the line contains a website title & B3, B4 \\ \hline
        6 false & the line doesn't contain a website title & B2 \\ \hline
        7 true & listOfWords is null & B2, B4 \\ \hline
        7 false & listOfWords is not null & B4 \\ \hline
    \end{tabular}
\end{table}

From the coverage table an expectancy table was produced.

\begin{table}[!h]
    \caption{Expectancy table of the JUnit tests}
    \begin{tabular}{|l|p{85pt}|p{100pt}|p{100pt}|}
        \hline
        \textbf{Input data set} & \textbf{Input data} & \textbf{Expected output} & \textbf{Actual output} \\ \hline
        A & "wrongfilename.txt" & Exception & FileNotFoundException \\ \hline
        B1 & "data/test-file1.txt" & returns an ArrayList<website>, size() == 0 & returns an ArrayList<website>, size() == 0 \\ \hline
        B2 & "data/test-file2.txt" & returns an ArrayList<website>, size() == 0 & returns an ArrayList<website>, size() == 0 \\ \hline
        B3 & "data/test-file3.txt" & returns an ArrayList<website>, size() == 0 & returns an ArrayList<website>, size() == 1 \\ \hline
        B4 & "data/test-file-errors.txt" & returns an ArrayList<website>, size() == 2 & returns an ArrayList<website>, size() == 2 \\ \hline
        B4 & "data/test-file4.txt" & returns an ArrayList<website>, size() == 2 & returns an ArrayList<website>, size() == 2 \\ \hline
    \end{tabular}
    \label{FH:resuts}
\end{table}

where data/test-file1.txt is an empty file, and the rest contained the following data:

\begin{table}[!h]
    \begin{tabular}{|l|l|l|l|}
        \hline
        \begin{minipage}[c]{0.12\columnwidth}
            \textbf{data/test\\-file2.txt} \\
        \end{minipage} &
        \begin{minipage}[c]{0.24\columnwidth}
            \textbf{data/test-file3.txt} \\
        \end{minipage} &
        \begin{minipage}[c]{0.32\columnwidth}
            \textbf{data/test-file4.txt} \\
        \end{minipage} &
        \begin{minipage}[c]{0.35\columnwidth}
            \textbf{data/test-file-errors.txt} \\
        \end{minipage} \tabularnewline \hline

        \begin{minipage}[t]{0.12\columnwidth}%
            word3 %
        \end{minipage} &
        \begin{minipage}[t]{0.24\columnwidth}%
            http://example.com \\
            Title1%
        \end{minipage} &
        \begin{minipage}[t]{0.32\columnwidth}%
            *PAGE:http://page1.com \\
            Title1 \\
            word1 \\
            word2 \\
            *PAGE:http://page2.com \\
            Title2 \\
            word1 \\
            word3 %
        \end{minipage} &
        \begin{minipage}[t]{0.35\columnwidth}%
            word1 \\
            word2 \\
            *PAGE:http://page1.com \\
            Title1 \\
            word1 \\
            word2 \\
            *PAGE:http://wrong1.com \\
            Title1 \\
            *PAGE:http://wrong2.com \\
            *PAGE:http://wrong3.com \\
            Titleword1 Titleword2 \\
            *PAGE:http://page2.com \\
            Title2 \\
            word1 \\
            word3 \\%
        \end{minipage} \tabularnewline \hline
    \end{tabular}
\end{table}

As you can see from the Actual Output column of \ref{FH:result}, the updated code failed test B3, highlighting a weakness in the code, and subsequently had to be debugged. Including another IF statement after the while loop resolved the issue, and following that all tests were passed.

\subsubsection{Index tests}






%How to reference surce\footnotemark. 
%\footnotetext{Oracle \url{https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html}} 

%How to reference surce\footnotemark. 
%\footnotetext{Oracle \url{https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html}} 