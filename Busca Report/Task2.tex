\chapter{Refines Queries}

%• Task: A short review on the task that we had to solve.
%• Basic Approach: A basic description on how we solved the task.
%• Technical description: Description of software architecture used in the solution.
%• Testing considerations: Description of considerations for testing the correctness
%of our solution.
%• Benchmarking/Reection: Benchmarking results for experiments that allowed us
%choose the best data structure for the search engine.

%Checklist for Mandatory Tasks
%Use the following checklist to make sure your project fulfills all mandatory tasks.
% Tasks 1–3 have correspondent Java code that solve them, in particular,
% you have implemented the inverted indexes, and benchmarked them,
% your searchengine understands complex queries,
% your searchengine is able to rank results to a query, using dierent scores.
% each class and each method is documented using Javadoc
% each class is accompanied with a unit test, in which you test the public methods
%exposed by the class (no tests need to be provided for main and “getter” methods)

\section{Task} % A short review on the task that we had to solve.
This task enables complex query handling. This is a basic feature that is expected from a search engine: to be able to understand queries that consist of more than just one word. Additionally, we were asked to enable a feature that aggregates results from different (possibly) multi-word queries when the ``{\tt OR}'' keyword is present.

\section{Basic Approach} % A basic description on how we solved the task.
All the logic necessary to handle the queries was implemented in the class {\tt QueryHandler}.
When considering what needs to be accomplished as well as what the user can input in the search field, the present task is accomplished by following these steps:
\begin{enumerate}
    \item Sanitise the query: this comprises of checking if the query is meaningful and fulfils basic criteria in morphological terms, and to enforce it in the cases it does not.
    \item Separate the query into sub-queries whenever the ``{\tt OR}'' keyword is present.
    \item For each of the sub-queries, find websites that contain all the words in that sub-query.
    \item Aggregate all the results of the multiple sub-queries on a list.
\end{enumerate}
In order to achieve encapsulation and responsibility-driven design, the following methods were implemented in the above-mentioned class:
\begin{itemize}
    \item {\tt getMatchingWebsites}: Core method of the class. It is responsible for:
    \begin{itemize}
        \item Receiving the input and passing it to the {\tt cleanQuery} helper method.
        \item Receiving the input from the {\tt cleanQuery} method in a meaningful and orderly fashion, passing it then, element by element, to the {\tt intersectedSearch} method.
        \item Receiving every result of the {\tt intersectedSearch} method and store it, so that when every element of the list is processed, it returns the matching websites.
    \end{itemize}
    \item {\tt cleanQuery}: Auxiliary private method to make sure that the input is free from unaccounted of irrelevant input.
    \item {\tt intersectedSearch}: Auxiliary private method that returns websites that match simultaneously all the words in the input {\tt String} parameter.
\end{itemize}

\section{Technical description} % Description of software architecture used in the solution.
\subsection{Field}
The {\tt QueryHandler} class takes an {\tt Index} object as the initialising parameter. This {\tt Index} can be any of the indexes described in the previous chapter, as it consists of an {\tt interface}. This was achieved with the following piece of code:
\begin{lstlisting}[language=Java]
public class QueryHandler {
    private Index idx = null;
    public QueryHandler(Index idx) {
    this.idx = idx;
    }
\end{lstlisting}
\subsection{{\tt getMatchingWebsites} core method}
As soon as this class is instantiated, it's intended use expects the {\tt getMatchingWebsites} method to be called. This method takes in a {\tt String} as parameter, which consists of the search terms; and returns a {\tt List<Website>}, which consists of the matching results. The signature is as follows:
\begin{lstlisting}[language=Java]
public List<Website> getMatchingWebsites(String line) {
\end{lstlisting}
As the description in the Basic Approach reads, this method uses two auxiliary methods to process the data as necessary. The first data processing happens when the parameter is passed to {\tt cleanQuery} method, which then returns a list of Strings that can be used to proceed with the search. The code used to achieve this is the following:
\begin{lstlisting}[language=Java]
List<String> query = cleanQuery(line);
\end{lstlisting}
\subsection{{\tt cleanQuery} auxiliary method}
This method enforces consistency in the input to be later on used to search for results.
The first steps of the process consist of:
\begin{itemize}
    \item Replacing all the punctuation characters by spaces
    \item Replacing every one or more space characters by a single space character
\end{itemize}
The above mentioned steps are achieved with the following code:
\begin{lstlisting}[language=Java]
private List<String> cleanQuery (String input) {
input = input.replaceAll("\\p{Punct}", " ").replaceAll("\\s+", " ");
\end{lstlisting}
After this, the ``{\tt OR}'' keyword is used as criteria for splitting the input {\tt String}, which is then used to create a {\tt List<String> searches}. The idea is that every element of the list will consist of an intersected search, and the results of each search will then be aggregated to achieve the final result. The code that allows for the described step is as follows:
\begin{lstlisting}[language=Java]
List<String> searches = new ArrayList<>(Arrays.asList(input.split("OR")));
\end{lstlisting}
What follows is a sequence of steps that enforces consistency in our {\tt List<String> searches}. This can elegantly be achieved by using lambdas. You can find below the remaining steps, followed by a small description.
\begin{lstlisting}
searches.replaceAll(String::trim);
// trim all the searches, just in case they start or end with empty spaces

searches.removeAll(Arrays.asList(""));
// delete all empty entries

searches.replaceAll(String::toLowerCase);
// make everything lower case, because of the way the websites are crawled
\end{lstlisting}
Lastly, the result is returned:
\begin{lstlisting}
return searches;
}
\end{lstlisting}
\subsection{Intermediate steps in the {\tt getMatchingWebsites} method}
After having our input refined and organised on {\tt List<String> query}, it is time to perform the actual search. As previously explained, this is done by passing each element of such list to the auxiliary method {\tt intersectedSearch} and store the result of each iteration on a {\tt Set<Website> results}. The root of the reason for the choice of such data structure is the fact that it does not allow duplicates (as opposed to a {\tt List}, which expedites the process. Since we intend to iterate through a set of data, it seemed appropriate to implement a {\tt for} loop. The piece of code that implements this description is as follows:
\begin{lstlisting}
Set<Website> results = new HashSet<>();

for (String inputs : query) {
results.addAll(intersectedSearch(inputs));
}
\end{lstlisting}
\subsection{{\tt intersectedSearch} auxiliary method}
Given a certain {\tt String} parameter, this auxiliary private method returns a {\tt Set<Website>} where each of the {\tt Website}s matches simultaneously all the words in such parameter. Our approach to this consisted of the following steps:
\begin{itemize}
    \item Initialising a local variable, {\tt List<String> queriedWords}.
    \item Splitting the {\tt String input} (from the method parameter) by space characters.
    \item Converting the resulting {\tt String[]} to an {\tt ArrayList<String>}.
    \item Storing this result on {\tt queriedWords}.
\end{itemize}
This is achieved by the following piece of code:
\begin{lstlisting}
private Set<Website> intersectedSearch(String input) {
List<String> queriedWords = new ArrayList<>(Arrays.asList(input.split(" ")));
\end{lstlisting}
After having a {\tt List} of words to search for, the approach taken to find {\tt Website}s that match simultaneously all the words in such {\tt List} was the following:
\begin{itemize}
    \item Initialising a local variable, {\tt Set<Website> matches}, which will later on be returned by the method.
    \item Calling the {\tt lookup} method on the field {\tt Index idx}, providing the first element of {\tt List<String> queriedWords} as argument.
    \item Storing this result on {\tt matches}.
\end{itemize}
Should there be more than one word to intersect the results with, this first set of results will be used to compare with the results of the remaining words in the {\tt List<String> queriedWords}. In order to accomplish such task, the results of every other given word were successively compared with the results from the first element of the list. The refining criteria was to keep only the websites that were present on both lists. The code that fulfils this task looks like the following:
\begin{lstlisting}
if (queriedWords.size() > 1) {
for (String queriedWord : queriedWords) {
matches.retainAll(idx.lookup(queriedWord));
}
}
\end{lstlisting}
Lastly, the result is returned:
\begin{lstlisting}
return matches;
}
\end{lstlisting}
\subsection{Final steps in the {\tt getMatchingWebsites} method}
When all the results from each of the different intersected searches are gathered, they need to be put on a {\tt List <Website>} so it can be returned by the method. This is achieved by creating a {\tt new ArrayList<>} where the argument is the {\tt Set<Website> results}. This is achieved with the following piece of code:
\begin{lstlisting}
return new ArrayList<>(results);
}
\end{lstlisting}

\section{Testing considerations} % Description of considerations for testing the correctness of our solution.
Upon testing for correctness, we split the test cases in two main groups: one that tests basic functionality, and a second one that tests for bad user behaviour.
\begin{itemize}
    \item Testing for the basic functionality:
        \begin{itemize}
            \item One word
            \item One or more words separated by spaces;
            \item Two words with the ``{\tt OR}'' keyword in between;
            \item Groups of words separated by the ``{\tt OR}'' and by spaces;
        \end{itemize}
    \item Testing for bad user behaviour, where the query:
    \begin{itemize}
        \item Is empty;
        \item Starts with white space followed by the ``{\tt OR}'' keyword;
        \item Repeats the words separated by the ``{\tt OR}'' keyword;
        \item Consists of solely the ``{\tt OR}'' keyword;
        \item Starts with the ``{\tt OR}'' keyword followed groups of words separated by spaces;
        \item Starts with white space followed by the ``{\tt OR}'' keyword followed groups of words separated by the ``{\tt OR}'' and by spaces and ends with ``{\tt OR}'' ;
        \item Consists of only white space;
        \item Starts with punctuation and white space and is followed by a group of words separated by spaces;
        \item Consists of several ``{\tt OR}'' keywords separated by spaces, followed by a group of words separated by spaces and ends with several ``{\tt OR}'' keywords separated by spaces;
        \item Consists of several words separated by the ``{\tt OR}'' keyword where there is more that one ``{\tt OR}'' occurrence between words;
        \item Contains only upper case characters;
        \item Contains no spaces but a word surrounded by several ``{\tt OR}'' keywords;
        \item Contains an upper case word next to an ``{\tt OR}'' keyword with no spaces in between, followed by another ``{\tt OR}'' keyword and a word.
        \item Lastly, we considered the worst case scenario where a query contained many of the above-mentioned cases and also for when there was punctuation between words.
    \end{itemize}
\end{itemize}

\section{Reflection} % Benchmarking results for experiments that allowed us choose the best data structure for the search engine.

